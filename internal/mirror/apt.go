package mirror

import (
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"strings"
)

// AptMirror handles apt sources configuration
type AptMirror struct {
	mirrorURL string
}

// NewAptMirror creates a new Apt mirror handler
func NewAptMirror(mirrorURL string) *AptMirror {
	return &AptMirror{
		mirrorURL: mirrorURL,
	}
}

// detectUbuntuVersion detects the Ubuntu/Debian version codename
func detectUbuntuVersion() (string, error) {
	// Try to read /etc/os-release
	data, err := os.ReadFile("/etc/os-release")
	if err != nil {
		return "", fmt.Errorf("failed to read /etc/os-release: %w", err)
	}

	lines := strings.Split(string(data), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "VERSION_CODENAME=") {
			return strings.TrimPrefix(line, "VERSION_CODENAME="), nil
		}
		if strings.HasPrefix(line, "UBUNTU_CODENAME=") {
			return strings.TrimPrefix(line, "UBUNTU_CODENAME="), nil
		}
	}

	// Fallback: try lsb_release command
	cmd := exec.Command("lsb_release", "-cs")
	output, err := cmd.Output()
	if err == nil {
		return strings.TrimSpace(string(output)), nil
	}

	return "", fmt.Errorf("failed to detect Ubuntu version")
}

// Enable configures apt to use the mirror
func (a *AptMirror) Enable() error {
	// Only works on Linux
	if runtime.GOOS != "linux" {
		return fmt.Errorf("apt mirror only works on Linux systems")
	}

	// Detect Ubuntu version
	codename, err := detectUbuntuVersion()
	if err != nil {
		return fmt.Errorf("failed to detect Ubuntu version: %w", err)
	}

	sourcesPath := "/etc/apt/sources.list"
	backupPath := "/etc/apt/sources.list.crosh.backup"

	// Backup original sources.list if not already backed up
	if _, err := os.Stat(backupPath); os.IsNotExist(err) {
		data, err := os.ReadFile(sourcesPath)
		if err != nil {
			return fmt.Errorf("failed to read sources.list: %w", err)
		}
		if err := os.WriteFile(backupPath, data, 0644); err != nil {
			return fmt.Errorf("failed to backup sources.list: %w", err)
		}
	}

	// Generate new sources.list content
	content := fmt.Sprintf(`# Generated by crosh - Chinese mirror acceleration
deb http://%s/ubuntu/ %s main restricted universe multiverse
deb http://%s/ubuntu/ %s-updates main restricted universe multiverse
deb http://%s/ubuntu/ %s-backports main restricted universe multiverse
deb http://%s/ubuntu/ %s-security main restricted universe multiverse
`, a.mirrorURL, codename, a.mirrorURL, codename, a.mirrorURL, codename, a.mirrorURL, codename)

	// Write new sources.list (requires sudo)
	if err := os.WriteFile(sourcesPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write sources.list (try running with sudo): %w", err)
	}

	return nil
}

// Disable restores the original apt sources
func (a *AptMirror) Disable() error {
	if runtime.GOOS != "linux" {
		return fmt.Errorf("apt mirror only works on Linux systems")
	}

	sourcesPath := "/etc/apt/sources.list"
	backupPath := "/etc/apt/sources.list.crosh.backup"

	// Restore from backup
	if _, err := os.Stat(backupPath); os.IsNotExist(err) {
		return fmt.Errorf("no backup found to restore")
	}

	data, err := os.ReadFile(backupPath)
	if err != nil {
		return fmt.Errorf("failed to read backup: %w", err)
	}

	if err := os.WriteFile(sourcesPath, data, 0644); err != nil {
		return fmt.Errorf("failed to restore sources.list: %w", err)
	}

	// Remove backup file
	os.Remove(backupPath)

	return nil
}

// Status checks if the mirror is currently enabled
func (a *AptMirror) Status() (bool, string, error) {
	if runtime.GOOS != "linux" {
		return false, "", fmt.Errorf("apt mirror only works on Linux systems")
	}

	sourcesPath := "/etc/apt/sources.list"
	data, err := os.ReadFile(sourcesPath)
	if err != nil {
		return false, "", fmt.Errorf("failed to read sources.list: %w", err)
	}

	content := string(data)
	if strings.Contains(content, "Generated by crosh") {
		lines := strings.Split(content, "\n")
		for _, line := range lines {
			if strings.HasPrefix(strings.TrimSpace(line), "deb http://") {
				parts := strings.Fields(line)
				if len(parts) >= 2 {
					return true, parts[1], nil
				}
			}
		}
	}

	return false, "default sources", nil
}
